import * as anchor from "@project-serum/anchor";
import { Program, BN } from "@project-serum/anchor";
import {
  PublicKey,
  Keypair,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";

import {
  getAssociatedTokenAddress,
  TOKEN_PROGRAM_ID,
  ASSOCIATED_TOKEN_PROGRAM_ID,
} from "@solana/spl-token";

import { assert } from "chai";
import path from "path";
import { BondingCurve } from "../target/types/bonding_curve";

// Metaplex Metadata program ID
const METAPLEX_PROGRAM_ID = new PublicKey(
  "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
);

// Token factory program ID
const TOKEN_FACTORY_PROGRAM_ID = new PublicKey(
  "TF5AoQEG87r1gpWsNzADMxYean6tfdGVUouQQ5LbYPP"
);

// Adjust these paths/keys to suit your environment:
const DEVNET_URL = "https://api.devnet.solana.com";
const CREATOR_KEYPAIR_PATH = path.join(
  process.env.HOME!,
  ".config",
  "solana",
  "devnet-owner.json"
);
const BUYER_KEYPAIR_PATH = path.join(
  process.env.HOME!,
  ".config",
  "solana",
  "devnet-buyer.json"
);

// Base (payment) token mint
const PAYMENT_MINT_PUBKEY = new PublicKey(
  "6WQQPDXsBxkgMwuApkXbV2bUf3CZAJmGBDqk62aMpmKR"
);

// Test constants
const TOTAL_TOKENS = new BN("1073000191");
const BONDING_K_VIRTUAL = new BN("32190005730").mul(new BN(LAMPORTS_PER_SOL));
const VIRTUAL_POOL_OFFSET = new BN(30 * LAMPORTS_PER_SOL);
const GRADUATE_DOLLARS_AMOUNT = 1000000; // (u32)
const DECIMALS = 9; // new token decimals

// Metadata parameters for the project token
const tokenName = "TEST_TOKEN";
const tokenSymbol = "TST";
const tokenUri = "https://ekza.io/ipfs/QmVjBTRsbAM96BnNtZKrR8i3hGRbkjnQ3kugwXn6BVFu2k";


describe("Bonding Curve Program (Token Init Only) - Split Into 3 Tx", () => {
  // Initialize Anchor provider and program
  const connection = new anchor.web3.Connection(DEVNET_URL, {
    commitment: "processed",
  });
  const creatorSecret = require(CREATOR_KEYPAIR_PATH);
  const creatorKeypair = Keypair.fromSecretKey(new Uint8Array(creatorSecret));
  const wallet = new anchor.Wallet(creatorKeypair);
  const provider = new anchor.AnchorProvider(connection, wallet, {});
  anchor.setProvider(provider);

  // The BondingCurve program as generated by Anchor.
  const program = anchor.workspace.BondingCurve as Program<BondingCurve>;

  // Variables to hold state
  let tokenSeedKeypair: Keypair;
  let xyberTokenPda: PublicKey;
  let mintPda: PublicKey;
  let vaultTokenAccount: PublicKey;
  let creatorTokenAccount: PublicKey;
  let escrowTokenAccount: PublicKey; // for payment tokens
  let metadataPda: PublicKey;

  before("Derive all PDAs", async () => {
    // Generate ephemeral keypair for seed account
    tokenSeedKeypair = Keypair.generate();

    // Derive the PDA for XyberToken
    [xyberTokenPda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("xyber_token"),
        creatorKeypair.publicKey.toBuffer(),
        tokenSeedKeypair.publicKey.toBuffer(),
      ],
      program.programId
    );

    // Derive the mint PDA (token_factory seeds)
    [mintPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("MINT"), tokenSeedKeypair.publicKey.toBuffer()],
      TOKEN_FACTORY_PROGRAM_ID
    );

    // Escrow ATA for the base (payment) token
    escrowTokenAccount = await getAssociatedTokenAddress(
      PAYMENT_MINT_PUBKEY,
      xyberTokenPda,
      true
    );

    // ATA for the project token (optional - for the creator)
    creatorTokenAccount = await getAssociatedTokenAddress(
      mintPda,
      creatorKeypair.publicKey
    );

    // Metadata PDA for the mint
    [metadataPda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("metadata"),
        METAPLEX_PROGRAM_ID.toBuffer(),
        mintPda.toBuffer(),
      ],
      METAPLEX_PROGRAM_ID
    );

    // ATA for the vault (owned by xyberTokenPda) if needed
    vaultTokenAccount = await getAssociatedTokenAddress(
      mintPda,
      xyberTokenPda,
      true
    );
  });

  it.only("1) init_core_instruction", async () => {
    console.log("----- Step 1: init_core_instruction -----");
    const createTokenParams = {
      tokenSupply: TOTAL_TOKENS,
      tokenGradThrUsd: 999, // example
      bondingCurve: {
        aTotalTokens: TOTAL_TOKENS,
        kVirtualPoolOffset: BONDING_K_VIRTUAL,
        cBondingScaleFactor: VIRTUAL_POOL_OFFSET,
        xTotalBaseDeposit: new BN(0),
      },
      acceptedBaseMint: PAYMENT_MINT_PUBKEY,
      admin: creatorKeypair.publicKey,
      graduateDollarsAmount: GRADUATE_DOLLARS_AMOUNT,
    };

    const ixCore = await program.methods
      .initCoreInstruction(createTokenParams)
      .accounts({
        tokenSeed: tokenSeedKeypair.publicKey,
        creator: creatorKeypair.publicKey,
        xyberToken: xyberTokenPda,
        systemProgram: SystemProgram.programId,
      })
      .signers([creatorKeypair])
      .instruction();

    const txCore = new Transaction().add(ixCore);

    console.log("Sending init_core_instruction transaction...");
    const sigCore = await provider.sendAndConfirm(txCore, [
      creatorKeypair,
    ]);
    console.log("init_core_instruction SUCCESS, signature =", sigCore);

    // Optionally fetch the state here:
    const xyberState = await program.account.xyberToken.fetch(xyberTokenPda);
    console.log("After init_core, XYBER state:", xyberState);
  });

  it.only("2) init_and_mint_full_supply_instruction", async () => {
    console.log("----- Step 2: init_and_mint_full_supply_instruction -----");
    // Build the instruction
    const ixMintFullSupply = await program.methods
      .initAndMintFullSupplyInstruction(tokenName, tokenSymbol, tokenUri)
      .accounts({
        xyberToken: xyberTokenPda,
        tokenSeed: tokenSeedKeypair.publicKey,
        creator: creatorKeypair.publicKey,
        mint: mintPda,
        vaultTokenAccount: vaultTokenAccount,
        metadataAccount: metadataPda,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        tokenMetadataProgram: METAPLEX_PROGRAM_ID,
        tokenProgram: TOKEN_PROGRAM_ID,
        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        systemProgram: anchor.web3.SystemProgram.programId,

        tokenFactoryProgram: TOKEN_FACTORY_PROGRAM_ID,
      })
      .instruction();

    // Send transaction
    const txMintFullSupply = new Transaction().add(ixMintFullSupply);

    console.log(
      "Sending init_and_mint_full_supply_instruction transaction..."
    );
    // Note: only your creatorKeypair + tokenSeedKeypair if needed
    // But *usually* you'd sign by [creatorKeypair, tokenSeedKeypair]
    // if your instruction requires them both. Check your anchor constraints.
    const sigMintFullSupply = await provider.sendAndConfirm(
      txMintFullSupply,
      [creatorKeypair]
    );
    console.log(
      "init_and_mint_full_supply_instruction SUCCESS, signature =",
      sigMintFullSupply
    );

    // Optionally fetch the state here:
    const xyberState = await program.account.xyberToken.fetch(xyberTokenPda);
    console.log("After init_and_mint_full_supply, XYBER state:", xyberState);
  });

  it.only("3) mint_initial_tokens_instruction", async () => {
    console.log("----- Step 3: mint_initial_tokens_instruction -----");

    // Let's say we deposit 0.001 SOL worth of base token
    // const depositLamports = new BN(0.001 * LAMPORTS_PER_SOL); // TODO: restore this logic when 
    // TODO: pow to decimals should be added here https://gitlab.xyber-labs.com/xyber/ets/uts-solana/-/blob/develop/programs/token_factory/src/lib.rs#L66
    const depositLamports = new BN(1);

    // Creator's payment account for base token
    const creatorPaymentAccount = await getAssociatedTokenAddress(
      PAYMENT_MINT_PUBKEY,
      creatorKeypair.publicKey
    );

    const ixMintInitial = await program.methods
      .mintInitialTokensInstruction(depositLamports)
      .accounts({
        tokenSeed: tokenSeedKeypair.publicKey,
        creator: creatorKeypair.publicKey,
        xyberToken: xyberTokenPda,
        escrowTokenAccount: escrowTokenAccount,
        paymentMint: PAYMENT_MINT_PUBKEY,
        creatorPaymentAccount: creatorPaymentAccount,
        mint: mintPda,
        vaultTokenAccount: vaultTokenAccount,
        creatorTokenAccount: creatorTokenAccount,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .signers([creatorKeypair])
      .instruction();

    const txMintInitial = new Transaction().add(ixMintInitial);

    console.log("Sending mint_initial_tokens_instruction transaction...");
    const sigMintInitial = await provider.sendAndConfirm(txMintInitial, [
      creatorKeypair,
    ]);
    console.log(
      "mint_initial_tokens_instruction SUCCESS, signature =",
      sigMintInitial
    );

    // Final check
    const xyberState = await program.account.xyberToken.fetch(xyberTokenPda);
    console.log("After mint_initial_tokens, XYBER state:", xyberState);

    // You could also check token balances, etc., to ensure it worked.
  });




  // it("Step 2) Buyer buys token with exact base input (buy_exact_input_instruction)", async () => {
  // Derive the buyer's ATA for the project token.
  // buyerTokenAccount = await getAssociatedTokenAddress(
  //   projectMintKeypair.publicKey,
  //   buyerKeypair.publicKey
  // );

  // // Derive the buyer's ATA for the payment token.
  // buyerPaymentAccount = await getAssociatedTokenAddress(
  //   PAYMENT_MINT_PUBKEY,
  //   buyerKeypair.publicKey
  // );

  // // Let’s deposit 0.002 SOL of base:
  // const baseIn = new BN(0.002 * LAMPORTS_PER_SOL);

  // await program.methods
  //   .buyExactInputInstruction(baseIn)
  //   .accounts({
  //     tokenSeed: tokenSeedKeypair.publicKey,
  //     buyer: buyerKeypair.publicKey,
  //     creator: creatorKeypair.publicKey,
  //     xyberToken: xyberTokenPda,
  //     escrowTokenAccount: escrowTokenAccount,
  //     paymentMint: PAYMENT_MINT_PUBKEY,
  //     mint: projectMintKeypair.publicKey,
  //     vaultTokenAccount: vaultTokenAccount,
  //     buyerTokenAccount: buyerTokenAccount,
  //     buyerPaymentAccount: buyerPaymentAccount,
  //     associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
  //     tokenProgram: TOKEN_PROGRAM_ID,
  //     systemProgram: SystemProgram.programId,
  //   })
  //   .signers([buyerKeypair])
  //   .rpc();

  // const buyerAtaInfo = await getAccount(connection, buyerTokenAccount);
  // console.log("Buyer ATA after buyExactInput =>", buyerAtaInfo.amount.toString());
  // assert(
  //   buyerAtaInfo.amount > BigInt(0),
  //   "Buyer should have some project tokens after the purchase"
  // );
  // });

  // it("Step 3) Buyer sells token with exact input (sell_exact_input_instruction)", async () => {
  // Let’s sell half of the tokens the buyer has.
  // const buyerAtaInfo = await getAccount(connection, buyerTokenAccount);
  // const tokensBuyerHas = buyerAtaInfo.amount;
  // const halfTokensInCurveUnits = new BN(tokensBuyerHas.toString())
  //   .divn(2)
  //   .divn(10 ** DECIMALS);

  // await program.methods
  //   .sellExactInputInstruction(halfTokensInCurveUnits)
  //   .accounts({
  //     tokenSeed: tokenSeedKeypair.publicKey,
  //     user: buyerKeypair.publicKey,
  //     creator: creatorKeypair.publicKey,
  //     xyberToken: xyberTokenPda,
  //     escrowTokenAccount: escrowTokenAccount,
  //     paymentMint: PAYMENT_MINT_PUBKEY,
  //     mint: projectMintKeypair.publicKey,
  //     vaultTokenAccount: vaultTokenAccount,
  //     userTokenAccount: buyerTokenAccount,
  //     userPaymentAccount: buyerPaymentAccount,
  //     associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
  //     tokenProgram: TOKEN_PROGRAM_ID,
  //     systemProgram: SystemProgram.programId,
  //   })
  //   .signers([buyerKeypair])
  //   .rpc();

  // const buyerAtaInfoAfter = await getAccount(connection, buyerTokenAccount);
  // assert(
  //   buyerAtaInfoAfter.amount < buyerAtaInfo.amount,
  //   "Buyer’s token balance should decrease after selling"
  // );
  // console.log(
  //   "SellExactInput done. Buyer tokens before=",
  //   buyerAtaInfo.amount.toString(),
  //   " after=",
  //   buyerAtaInfoAfter.amount.toString()
  // );
  // });

  // it("Step 4) Buyer buys EXACT output: e.g. 10 project tokens (buy_exact_output_instruction)", async () => {
  // const tokensOutWanted = new BN(10); // in "curve units" (before decimal scaling)
  // const buyerAtaInfoBefore = await getAccount(connection, buyerTokenAccount);
  // const buyerTokensBefore = buyerAtaInfoBefore.amount;

  // await program.methods
  //   .buyExactOutputInstruction(tokensOutWanted)
  //   .accounts({
  //     tokenSeed: tokenSeedKeypair.publicKey,
  //     buyer: buyerKeypair.publicKey,
  //     creator: creatorKeypair.publicKey,
  //     xyberToken: xyberTokenPda,
  //     escrowTokenAccount: escrowTokenAccount,
  //     paymentMint: PAYMENT_MINT_PUBKEY,
  //     mint: projectMintKeypair.publicKey,
  //     vaultTokenAccount: vaultTokenAccount,
  //     buyerTokenAccount: buyerTokenAccount,
  //     buyerPaymentAccount: buyerPaymentAccount,
  //     associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
  //     tokenProgram: TOKEN_PROGRAM_ID,
  //     systemProgram: SystemProgram.programId,
  //   })
  //   .signers([buyerKeypair])
  //   .rpc();

  // const buyerAtaInfoAfter = await getAccount(connection, buyerTokenAccount);
  // const diff = buyerAtaInfoAfter.amount - buyerTokensBefore;
  // // Expect exactly tokensOutWanted * 10^decimals minted
  // const expectedRawMinted = tokensOutWanted.mul(new BN(10 ** DECIMALS));
  // assert(
  //   diff === BigInt(expectedRawMinted.toString()),
  //   `Expected minted=${expectedRawMinted}, but got diff=${diff}`
  // );
  // console.log("BuyExactOutput success. Minted raw =", diff.toString());
  // });

  // it("Step 5) Buyer sells EXACT output: requests 5,000 lamports back (sell_exact_output_instruction)", async () => {
  // const lamportsWanted = new BN(5000);
  // const buyerAtaInfoBefore = await getAccount(connection, buyerTokenAccount);
  // const buyerTokensBefore = buyerAtaInfoBefore.amount;

  // await program.methods
  //   .sellExactOutputInstruction(lamportsWanted)
  //   .accounts({
  //     tokenSeed: tokenSeedKeypair.publicKey,
  //     user: buyerKeypair.publicKey,
  //     creator: creatorKeypair.publicKey,
  //     xyberToken: xyberTokenPda,
  //     escrowTokenAccount: escrowTokenAccount,
  //     paymentMint: PAYMENT_MINT_PUBKEY,
  //     mint: projectMintKeypair.publicKey,
  //     vaultTokenAccount: vaultTokenAccount,
  //     userTokenAccount: buyerTokenAccount,
  //     userPaymentAccount: buyerPaymentAccount,
  //     associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
  //     tokenProgram: TOKEN_PROGRAM_ID,
  //     systemProgram: SystemProgram.programId,
  //   })
  //   .signers([buyerKeypair])
  //   .rpc();

  // const buyerAtaInfoAfter = await getAccount(connection, buyerTokenAccount);
  // const tokensBurned = buyerTokensBefore - buyerAtaInfoAfter.amount;
  // console.log("sellExactOutput => buyer burned:", tokensBurned.toString(), " raw tokens");
  // assert(tokensBurned > BigInt(0), "Expected to burn some positive number of tokens");
  // });

  // // TODO: add a test for withdraw_liquidity after graduation.
  // it("Optional Step 6) Withdraw liquidity after graduation (withdraw_liquidity)", async () => {
  // Uncomment and adjust the following if you wish to test withdraw_liquidity.
  /*
  const adminTokenAccount = await getAssociatedTokenAddress(
    PAYMENT_MINT_PUBKEY,
    creatorKeypair.publicKey
  );

  await program.methods
    .withdrawLiquidity(new BN(10000))
    .accounts({
      admin: creatorKeypair.publicKey,
      xyberToken: xyberTokenPda,
      token_seed: tokenSeedKeypair.publicKey,
      creator: creatorKeypair.publicKey,
      escrowTokenAccount: escrowTokenAccount,
      adminTokenAccount: adminTokenAccount,
      tokenProgram: TOKEN_PROGRAM_ID,
    })
    .signers([creatorKeypair])
    .rpc();

  console.log("WithdrawLiquidity success!");
  */
  // });

});